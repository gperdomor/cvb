---
title: Overriding Styles
description: Customize component styling with additional classes
---

Even with a robust variant system, you'll occasionally need to add custom styles to specific component instances. CVB addresses this need with the `class` and `className` props, which let you extend or override the styles generated by your recipes.

## When to Use Style Overrides

Style overrides are perfect for:

- One-off customizations for specific component instances
- Adding contextual styles based on parent components
- Implementing styles that don't warrant a dedicated variant
- Providing an escape hatch for component consumers

### Overriding styles on Standard Recipes

For recipes created with `cvb`, simply pass a `class` or `className` prop:

```ts title="components/badge.recipe.ts"
import { cvb } from 'cvb';
import type { VariantProps } from 'cvb';

export const badge = cvb({
  base: 'inline-flex items-center rounded-md gap-x-1.5 text-xs px-2 py-1',
  variants: {
    color: {
      green: 'bg-green-50 text-green-700',
      indigo: 'bg-indigo-50 text-indigo-700',
    },
  },
});

// Usage with style override
badge({
  color: 'indigo',
  class: 'uppercase font-bold', // className is also supported // [!code highlight]
});
// Result: 'inline-flex items-center rounded-md gap-x-1.5 text-xs px-2 py-1 bg-indigo-50 text-indigo-700 uppercase font-bold'
```

The override classes are appended to the end of the generated class string, allowing them to extend or override the recipe's styles.

### Overriding Styles on Slot Recipes

For recipes created with `svb`, provide an object containing overrides for specific slots:

```ts title="components/badge.recipe.ts"
import { svb } from 'cvb';

export const badge = svb({
  slots: ['root', 'dot'],
  base: {
    root: 'inline-flex items-center rounded-md gap-x-1.5 text-xs px-2 py-1',
    dot: 'size-1.5',
  },
  variants: {
    color: {
      green: {
        root: 'bg-green-50 text-green-700',
        dot: 'fill-green-500',
      },
      indigo: {
        root: 'bg-indigo-50 text-indigo-700',
        dot: 'fill-indigo-500',
      },
    },
  },
});

// Usage with slot-specific overrides
badge({
  color: 'green',
  // [!code highlight:4]
  class: { // className is also supported
    root: 'uppercase font-bold',
    dot: 'animate-ping opacity-75',
  },
});
// Result:
// {
//   root: 'inline-flex items-center rounded-md gap-x-1.5 text-xs px-2 py-1 bg-green-50 text-green-700 uppercase font-bold',
//   dot: 'size-1.5 fill-green-500 animate-ping opacity-75',
// }
```

The override classes are applied to each specified slot, allowing for granular control over each component part.

## Implementing Overrides in Components

When creating React components with CVB recipes, you should always pass through the className prop:

```tsx
import { badge } from './badge.recipe';
import { VariantProps } from 'cvb';

type BadgeProps = VariantProps<typeof badge> & {
  children: React.ReactNode;
  className?: string; // Always include this prop // [!code highlight]
};

export function Badge({ children, className, ...props }: BadgeProps) {
  return (
    <span className={badge({ ...props, className })}>
      {children}
    </span>
  );
}
```

This pattern ensures that component consumers can add custom styles when needed.

### Best Practices for Style Overrides

- **Use Sparingly:** Overrides should be the exception, not the rule
- **Consider Adding Variants:** If you find yourself repeatedly using the same override, consider adding it as a variant
- **Be Mindful of Specificity:** Remember that order matters in CSS, and some overrides might require !important or higher specificity selectors
- **Document Override Points:** Let component consumers know which parts of your component are designed to be customized

<Callout type="info">
  When working with Tailwind CSS, consider using `tailwind-merge` to handle class conflicts between your recipe styles and
  overrides. See our Tailwind CSS integration [guide](./tailwindcss) for details.
</Callout>
